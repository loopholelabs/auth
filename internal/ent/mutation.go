/*
	Copyright 2023 Loophole Labs

	Licensed under the Apache License, Version 2.0 (the "License");
	you may not use this file except in compliance with the License.
	You may obtain a copy of the License at

		   http://www.apache.org/licenses/LICENSE-2.0

	Unless required by applicable law or agreed to in writing, software
	distributed under the License is distributed on an "AS IS" BASIS,
	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	See the License for the specific language governing permissions and
	limitations under the License.
*/

// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/loopholelabs/auth/internal/ent/deviceflow"
	"github.com/loopholelabs/auth/internal/ent/githubflow"
	"github.com/loopholelabs/auth/internal/ent/googleflow"
	"github.com/loopholelabs/auth/internal/ent/magicflow"
	"github.com/loopholelabs/auth/internal/ent/predicate"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeDeviceFlow = "DeviceFlow"
	TypeGithubFlow = "GithubFlow"
	TypeGoogleFlow = "GoogleFlow"
	TypeMagicFlow  = "MagicFlow"
)

// DeviceFlowMutation represents an operation that mutates the DeviceFlow nodes in the graph.
type DeviceFlowMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *time.Time
	last_poll     *time.Time
	identifier    *string
	device_code   *string
	user_code     *string
	session       *string
	expires_at    *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*DeviceFlow, error)
	predicates    []predicate.DeviceFlow
}

var _ ent.Mutation = (*DeviceFlowMutation)(nil)

// deviceflowOption allows management of the mutation configuration using functional options.
type deviceflowOption func(*DeviceFlowMutation)

// newDeviceFlowMutation creates new mutation for the DeviceFlow entity.
func newDeviceFlowMutation(c config, op Op, opts ...deviceflowOption) *DeviceFlowMutation {
	m := &DeviceFlowMutation{
		config:        c,
		op:            op,
		typ:           TypeDeviceFlow,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDeviceFlowID sets the ID field of the mutation.
func withDeviceFlowID(id int) deviceflowOption {
	return func(m *DeviceFlowMutation) {
		var (
			err   error
			once  sync.Once
			value *DeviceFlow
		)
		m.oldValue = func(ctx context.Context) (*DeviceFlow, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DeviceFlow.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDeviceFlow sets the old DeviceFlow of the mutation.
func withDeviceFlow(node *DeviceFlow) deviceflowOption {
	return func(m *DeviceFlowMutation) {
		m.oldValue = func(context.Context) (*DeviceFlow, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DeviceFlowMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DeviceFlowMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DeviceFlowMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DeviceFlowMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DeviceFlow.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *DeviceFlowMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DeviceFlowMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the DeviceFlow entity.
// If the DeviceFlow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceFlowMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DeviceFlowMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetLastPoll sets the "last_poll" field.
func (m *DeviceFlowMutation) SetLastPoll(t time.Time) {
	m.last_poll = &t
}

// LastPoll returns the value of the "last_poll" field in the mutation.
func (m *DeviceFlowMutation) LastPoll() (r time.Time, exists bool) {
	v := m.last_poll
	if v == nil {
		return
	}
	return *v, true
}

// OldLastPoll returns the old "last_poll" field's value of the DeviceFlow entity.
// If the DeviceFlow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceFlowMutation) OldLastPoll(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastPoll is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastPoll requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastPoll: %w", err)
	}
	return oldValue.LastPoll, nil
}

// ResetLastPoll resets all changes to the "last_poll" field.
func (m *DeviceFlowMutation) ResetLastPoll() {
	m.last_poll = nil
}

// SetIdentifier sets the "identifier" field.
func (m *DeviceFlowMutation) SetIdentifier(s string) {
	m.identifier = &s
}

// Identifier returns the value of the "identifier" field in the mutation.
func (m *DeviceFlowMutation) Identifier() (r string, exists bool) {
	v := m.identifier
	if v == nil {
		return
	}
	return *v, true
}

// OldIdentifier returns the old "identifier" field's value of the DeviceFlow entity.
// If the DeviceFlow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceFlowMutation) OldIdentifier(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIdentifier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIdentifier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIdentifier: %w", err)
	}
	return oldValue.Identifier, nil
}

// ResetIdentifier resets all changes to the "identifier" field.
func (m *DeviceFlowMutation) ResetIdentifier() {
	m.identifier = nil
}

// SetDeviceCode sets the "device_code" field.
func (m *DeviceFlowMutation) SetDeviceCode(s string) {
	m.device_code = &s
}

// DeviceCode returns the value of the "device_code" field in the mutation.
func (m *DeviceFlowMutation) DeviceCode() (r string, exists bool) {
	v := m.device_code
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceCode returns the old "device_code" field's value of the DeviceFlow entity.
// If the DeviceFlow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceFlowMutation) OldDeviceCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceCode: %w", err)
	}
	return oldValue.DeviceCode, nil
}

// ResetDeviceCode resets all changes to the "device_code" field.
func (m *DeviceFlowMutation) ResetDeviceCode() {
	m.device_code = nil
}

// SetUserCode sets the "user_code" field.
func (m *DeviceFlowMutation) SetUserCode(s string) {
	m.user_code = &s
}

// UserCode returns the value of the "user_code" field in the mutation.
func (m *DeviceFlowMutation) UserCode() (r string, exists bool) {
	v := m.user_code
	if v == nil {
		return
	}
	return *v, true
}

// OldUserCode returns the old "user_code" field's value of the DeviceFlow entity.
// If the DeviceFlow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceFlowMutation) OldUserCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserCode: %w", err)
	}
	return oldValue.UserCode, nil
}

// ResetUserCode resets all changes to the "user_code" field.
func (m *DeviceFlowMutation) ResetUserCode() {
	m.user_code = nil
}

// SetSession sets the "session" field.
func (m *DeviceFlowMutation) SetSession(s string) {
	m.session = &s
}

// Session returns the value of the "session" field in the mutation.
func (m *DeviceFlowMutation) Session() (r string, exists bool) {
	v := m.session
	if v == nil {
		return
	}
	return *v, true
}

// OldSession returns the old "session" field's value of the DeviceFlow entity.
// If the DeviceFlow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceFlowMutation) OldSession(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSession is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSession requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSession: %w", err)
	}
	return oldValue.Session, nil
}

// ClearSession clears the value of the "session" field.
func (m *DeviceFlowMutation) ClearSession() {
	m.session = nil
	m.clearedFields[deviceflow.FieldSession] = struct{}{}
}

// SessionCleared returns if the "session" field was cleared in this mutation.
func (m *DeviceFlowMutation) SessionCleared() bool {
	_, ok := m.clearedFields[deviceflow.FieldSession]
	return ok
}

// ResetSession resets all changes to the "session" field.
func (m *DeviceFlowMutation) ResetSession() {
	m.session = nil
	delete(m.clearedFields, deviceflow.FieldSession)
}

// SetExpiresAt sets the "expires_at" field.
func (m *DeviceFlowMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *DeviceFlowMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the DeviceFlow entity.
// If the DeviceFlow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceFlowMutation) OldExpiresAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ClearExpiresAt clears the value of the "expires_at" field.
func (m *DeviceFlowMutation) ClearExpiresAt() {
	m.expires_at = nil
	m.clearedFields[deviceflow.FieldExpiresAt] = struct{}{}
}

// ExpiresAtCleared returns if the "expires_at" field was cleared in this mutation.
func (m *DeviceFlowMutation) ExpiresAtCleared() bool {
	_, ok := m.clearedFields[deviceflow.FieldExpiresAt]
	return ok
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *DeviceFlowMutation) ResetExpiresAt() {
	m.expires_at = nil
	delete(m.clearedFields, deviceflow.FieldExpiresAt)
}

// Where appends a list predicates to the DeviceFlowMutation builder.
func (m *DeviceFlowMutation) Where(ps ...predicate.DeviceFlow) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DeviceFlowMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DeviceFlowMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DeviceFlow, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DeviceFlowMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DeviceFlowMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DeviceFlow).
func (m *DeviceFlowMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DeviceFlowMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, deviceflow.FieldCreatedAt)
	}
	if m.last_poll != nil {
		fields = append(fields, deviceflow.FieldLastPoll)
	}
	if m.identifier != nil {
		fields = append(fields, deviceflow.FieldIdentifier)
	}
	if m.device_code != nil {
		fields = append(fields, deviceflow.FieldDeviceCode)
	}
	if m.user_code != nil {
		fields = append(fields, deviceflow.FieldUserCode)
	}
	if m.session != nil {
		fields = append(fields, deviceflow.FieldSession)
	}
	if m.expires_at != nil {
		fields = append(fields, deviceflow.FieldExpiresAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DeviceFlowMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case deviceflow.FieldCreatedAt:
		return m.CreatedAt()
	case deviceflow.FieldLastPoll:
		return m.LastPoll()
	case deviceflow.FieldIdentifier:
		return m.Identifier()
	case deviceflow.FieldDeviceCode:
		return m.DeviceCode()
	case deviceflow.FieldUserCode:
		return m.UserCode()
	case deviceflow.FieldSession:
		return m.Session()
	case deviceflow.FieldExpiresAt:
		return m.ExpiresAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DeviceFlowMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case deviceflow.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case deviceflow.FieldLastPoll:
		return m.OldLastPoll(ctx)
	case deviceflow.FieldIdentifier:
		return m.OldIdentifier(ctx)
	case deviceflow.FieldDeviceCode:
		return m.OldDeviceCode(ctx)
	case deviceflow.FieldUserCode:
		return m.OldUserCode(ctx)
	case deviceflow.FieldSession:
		return m.OldSession(ctx)
	case deviceflow.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	}
	return nil, fmt.Errorf("unknown DeviceFlow field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeviceFlowMutation) SetField(name string, value ent.Value) error {
	switch name {
	case deviceflow.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case deviceflow.FieldLastPoll:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastPoll(v)
		return nil
	case deviceflow.FieldIdentifier:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIdentifier(v)
		return nil
	case deviceflow.FieldDeviceCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceCode(v)
		return nil
	case deviceflow.FieldUserCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserCode(v)
		return nil
	case deviceflow.FieldSession:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSession(v)
		return nil
	case deviceflow.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	}
	return fmt.Errorf("unknown DeviceFlow field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DeviceFlowMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DeviceFlowMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeviceFlowMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown DeviceFlow numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DeviceFlowMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(deviceflow.FieldSession) {
		fields = append(fields, deviceflow.FieldSession)
	}
	if m.FieldCleared(deviceflow.FieldExpiresAt) {
		fields = append(fields, deviceflow.FieldExpiresAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DeviceFlowMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DeviceFlowMutation) ClearField(name string) error {
	switch name {
	case deviceflow.FieldSession:
		m.ClearSession()
		return nil
	case deviceflow.FieldExpiresAt:
		m.ClearExpiresAt()
		return nil
	}
	return fmt.Errorf("unknown DeviceFlow nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DeviceFlowMutation) ResetField(name string) error {
	switch name {
	case deviceflow.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case deviceflow.FieldLastPoll:
		m.ResetLastPoll()
		return nil
	case deviceflow.FieldIdentifier:
		m.ResetIdentifier()
		return nil
	case deviceflow.FieldDeviceCode:
		m.ResetDeviceCode()
		return nil
	case deviceflow.FieldUserCode:
		m.ResetUserCode()
		return nil
	case deviceflow.FieldSession:
		m.ResetSession()
		return nil
	case deviceflow.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	}
	return fmt.Errorf("unknown DeviceFlow field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DeviceFlowMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DeviceFlowMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DeviceFlowMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DeviceFlowMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DeviceFlowMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DeviceFlowMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DeviceFlowMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown DeviceFlow unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DeviceFlowMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown DeviceFlow edge %s", name)
}

// GithubFlowMutation represents an operation that mutates the GithubFlow nodes in the graph.
type GithubFlowMutation struct {
	config
	op                Op
	typ               string
	id                *int
	created_at        *time.Time
	state             *string
	verifier          *string
	challenge         *string
	next_url          *string
	organization      *string
	device_identifier *string
	clearedFields     map[string]struct{}
	done              bool
	oldValue          func(context.Context) (*GithubFlow, error)
	predicates        []predicate.GithubFlow
}

var _ ent.Mutation = (*GithubFlowMutation)(nil)

// githubflowOption allows management of the mutation configuration using functional options.
type githubflowOption func(*GithubFlowMutation)

// newGithubFlowMutation creates new mutation for the GithubFlow entity.
func newGithubFlowMutation(c config, op Op, opts ...githubflowOption) *GithubFlowMutation {
	m := &GithubFlowMutation{
		config:        c,
		op:            op,
		typ:           TypeGithubFlow,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGithubFlowID sets the ID field of the mutation.
func withGithubFlowID(id int) githubflowOption {
	return func(m *GithubFlowMutation) {
		var (
			err   error
			once  sync.Once
			value *GithubFlow
		)
		m.oldValue = func(ctx context.Context) (*GithubFlow, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().GithubFlow.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGithubFlow sets the old GithubFlow of the mutation.
func withGithubFlow(node *GithubFlow) githubflowOption {
	return func(m *GithubFlowMutation) {
		m.oldValue = func(context.Context) (*GithubFlow, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GithubFlowMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GithubFlowMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GithubFlowMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *GithubFlowMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().GithubFlow.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *GithubFlowMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *GithubFlowMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the GithubFlow entity.
// If the GithubFlow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GithubFlowMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *GithubFlowMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetState sets the "state" field.
func (m *GithubFlowMutation) SetState(s string) {
	m.state = &s
}

// State returns the value of the "state" field in the mutation.
func (m *GithubFlowMutation) State() (r string, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the GithubFlow entity.
// If the GithubFlow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GithubFlowMutation) OldState(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// ResetState resets all changes to the "state" field.
func (m *GithubFlowMutation) ResetState() {
	m.state = nil
}

// SetVerifier sets the "verifier" field.
func (m *GithubFlowMutation) SetVerifier(s string) {
	m.verifier = &s
}

// Verifier returns the value of the "verifier" field in the mutation.
func (m *GithubFlowMutation) Verifier() (r string, exists bool) {
	v := m.verifier
	if v == nil {
		return
	}
	return *v, true
}

// OldVerifier returns the old "verifier" field's value of the GithubFlow entity.
// If the GithubFlow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GithubFlowMutation) OldVerifier(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVerifier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVerifier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVerifier: %w", err)
	}
	return oldValue.Verifier, nil
}

// ResetVerifier resets all changes to the "verifier" field.
func (m *GithubFlowMutation) ResetVerifier() {
	m.verifier = nil
}

// SetChallenge sets the "challenge" field.
func (m *GithubFlowMutation) SetChallenge(s string) {
	m.challenge = &s
}

// Challenge returns the value of the "challenge" field in the mutation.
func (m *GithubFlowMutation) Challenge() (r string, exists bool) {
	v := m.challenge
	if v == nil {
		return
	}
	return *v, true
}

// OldChallenge returns the old "challenge" field's value of the GithubFlow entity.
// If the GithubFlow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GithubFlowMutation) OldChallenge(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChallenge is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChallenge requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChallenge: %w", err)
	}
	return oldValue.Challenge, nil
}

// ResetChallenge resets all changes to the "challenge" field.
func (m *GithubFlowMutation) ResetChallenge() {
	m.challenge = nil
}

// SetNextURL sets the "next_url" field.
func (m *GithubFlowMutation) SetNextURL(s string) {
	m.next_url = &s
}

// NextURL returns the value of the "next_url" field in the mutation.
func (m *GithubFlowMutation) NextURL() (r string, exists bool) {
	v := m.next_url
	if v == nil {
		return
	}
	return *v, true
}

// OldNextURL returns the old "next_url" field's value of the GithubFlow entity.
// If the GithubFlow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GithubFlowMutation) OldNextURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNextURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNextURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNextURL: %w", err)
	}
	return oldValue.NextURL, nil
}

// ResetNextURL resets all changes to the "next_url" field.
func (m *GithubFlowMutation) ResetNextURL() {
	m.next_url = nil
}

// SetOrganization sets the "organization" field.
func (m *GithubFlowMutation) SetOrganization(s string) {
	m.organization = &s
}

// Organization returns the value of the "organization" field in the mutation.
func (m *GithubFlowMutation) Organization() (r string, exists bool) {
	v := m.organization
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganization returns the old "organization" field's value of the GithubFlow entity.
// If the GithubFlow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GithubFlowMutation) OldOrganization(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganization is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganization requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganization: %w", err)
	}
	return oldValue.Organization, nil
}

// ClearOrganization clears the value of the "organization" field.
func (m *GithubFlowMutation) ClearOrganization() {
	m.organization = nil
	m.clearedFields[githubflow.FieldOrganization] = struct{}{}
}

// OrganizationCleared returns if the "organization" field was cleared in this mutation.
func (m *GithubFlowMutation) OrganizationCleared() bool {
	_, ok := m.clearedFields[githubflow.FieldOrganization]
	return ok
}

// ResetOrganization resets all changes to the "organization" field.
func (m *GithubFlowMutation) ResetOrganization() {
	m.organization = nil
	delete(m.clearedFields, githubflow.FieldOrganization)
}

// SetDeviceIdentifier sets the "device_identifier" field.
func (m *GithubFlowMutation) SetDeviceIdentifier(s string) {
	m.device_identifier = &s
}

// DeviceIdentifier returns the value of the "device_identifier" field in the mutation.
func (m *GithubFlowMutation) DeviceIdentifier() (r string, exists bool) {
	v := m.device_identifier
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceIdentifier returns the old "device_identifier" field's value of the GithubFlow entity.
// If the GithubFlow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GithubFlowMutation) OldDeviceIdentifier(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceIdentifier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceIdentifier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceIdentifier: %w", err)
	}
	return oldValue.DeviceIdentifier, nil
}

// ClearDeviceIdentifier clears the value of the "device_identifier" field.
func (m *GithubFlowMutation) ClearDeviceIdentifier() {
	m.device_identifier = nil
	m.clearedFields[githubflow.FieldDeviceIdentifier] = struct{}{}
}

// DeviceIdentifierCleared returns if the "device_identifier" field was cleared in this mutation.
func (m *GithubFlowMutation) DeviceIdentifierCleared() bool {
	_, ok := m.clearedFields[githubflow.FieldDeviceIdentifier]
	return ok
}

// ResetDeviceIdentifier resets all changes to the "device_identifier" field.
func (m *GithubFlowMutation) ResetDeviceIdentifier() {
	m.device_identifier = nil
	delete(m.clearedFields, githubflow.FieldDeviceIdentifier)
}

// Where appends a list predicates to the GithubFlowMutation builder.
func (m *GithubFlowMutation) Where(ps ...predicate.GithubFlow) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the GithubFlowMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *GithubFlowMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.GithubFlow, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *GithubFlowMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *GithubFlowMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (GithubFlow).
func (m *GithubFlowMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GithubFlowMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, githubflow.FieldCreatedAt)
	}
	if m.state != nil {
		fields = append(fields, githubflow.FieldState)
	}
	if m.verifier != nil {
		fields = append(fields, githubflow.FieldVerifier)
	}
	if m.challenge != nil {
		fields = append(fields, githubflow.FieldChallenge)
	}
	if m.next_url != nil {
		fields = append(fields, githubflow.FieldNextURL)
	}
	if m.organization != nil {
		fields = append(fields, githubflow.FieldOrganization)
	}
	if m.device_identifier != nil {
		fields = append(fields, githubflow.FieldDeviceIdentifier)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GithubFlowMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case githubflow.FieldCreatedAt:
		return m.CreatedAt()
	case githubflow.FieldState:
		return m.State()
	case githubflow.FieldVerifier:
		return m.Verifier()
	case githubflow.FieldChallenge:
		return m.Challenge()
	case githubflow.FieldNextURL:
		return m.NextURL()
	case githubflow.FieldOrganization:
		return m.Organization()
	case githubflow.FieldDeviceIdentifier:
		return m.DeviceIdentifier()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GithubFlowMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case githubflow.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case githubflow.FieldState:
		return m.OldState(ctx)
	case githubflow.FieldVerifier:
		return m.OldVerifier(ctx)
	case githubflow.FieldChallenge:
		return m.OldChallenge(ctx)
	case githubflow.FieldNextURL:
		return m.OldNextURL(ctx)
	case githubflow.FieldOrganization:
		return m.OldOrganization(ctx)
	case githubflow.FieldDeviceIdentifier:
		return m.OldDeviceIdentifier(ctx)
	}
	return nil, fmt.Errorf("unknown GithubFlow field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GithubFlowMutation) SetField(name string, value ent.Value) error {
	switch name {
	case githubflow.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case githubflow.FieldState:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	case githubflow.FieldVerifier:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVerifier(v)
		return nil
	case githubflow.FieldChallenge:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChallenge(v)
		return nil
	case githubflow.FieldNextURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNextURL(v)
		return nil
	case githubflow.FieldOrganization:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganization(v)
		return nil
	case githubflow.FieldDeviceIdentifier:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceIdentifier(v)
		return nil
	}
	return fmt.Errorf("unknown GithubFlow field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GithubFlowMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GithubFlowMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GithubFlowMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown GithubFlow numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GithubFlowMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(githubflow.FieldOrganization) {
		fields = append(fields, githubflow.FieldOrganization)
	}
	if m.FieldCleared(githubflow.FieldDeviceIdentifier) {
		fields = append(fields, githubflow.FieldDeviceIdentifier)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GithubFlowMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GithubFlowMutation) ClearField(name string) error {
	switch name {
	case githubflow.FieldOrganization:
		m.ClearOrganization()
		return nil
	case githubflow.FieldDeviceIdentifier:
		m.ClearDeviceIdentifier()
		return nil
	}
	return fmt.Errorf("unknown GithubFlow nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GithubFlowMutation) ResetField(name string) error {
	switch name {
	case githubflow.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case githubflow.FieldState:
		m.ResetState()
		return nil
	case githubflow.FieldVerifier:
		m.ResetVerifier()
		return nil
	case githubflow.FieldChallenge:
		m.ResetChallenge()
		return nil
	case githubflow.FieldNextURL:
		m.ResetNextURL()
		return nil
	case githubflow.FieldOrganization:
		m.ResetOrganization()
		return nil
	case githubflow.FieldDeviceIdentifier:
		m.ResetDeviceIdentifier()
		return nil
	}
	return fmt.Errorf("unknown GithubFlow field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GithubFlowMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GithubFlowMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GithubFlowMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GithubFlowMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GithubFlowMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GithubFlowMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GithubFlowMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown GithubFlow unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GithubFlowMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown GithubFlow edge %s", name)
}

// GoogleFlowMutation represents an operation that mutates the GoogleFlow nodes in the graph.
type GoogleFlowMutation struct {
	config
	op                Op
	typ               string
	id                *int
	created_at        *time.Time
	state             *string
	verifier          *string
	challenge         *string
	next_url          *string
	organization      *string
	device_identifier *string
	clearedFields     map[string]struct{}
	done              bool
	oldValue          func(context.Context) (*GoogleFlow, error)
	predicates        []predicate.GoogleFlow
}

var _ ent.Mutation = (*GoogleFlowMutation)(nil)

// googleflowOption allows management of the mutation configuration using functional options.
type googleflowOption func(*GoogleFlowMutation)

// newGoogleFlowMutation creates new mutation for the GoogleFlow entity.
func newGoogleFlowMutation(c config, op Op, opts ...googleflowOption) *GoogleFlowMutation {
	m := &GoogleFlowMutation{
		config:        c,
		op:            op,
		typ:           TypeGoogleFlow,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGoogleFlowID sets the ID field of the mutation.
func withGoogleFlowID(id int) googleflowOption {
	return func(m *GoogleFlowMutation) {
		var (
			err   error
			once  sync.Once
			value *GoogleFlow
		)
		m.oldValue = func(ctx context.Context) (*GoogleFlow, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().GoogleFlow.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGoogleFlow sets the old GoogleFlow of the mutation.
func withGoogleFlow(node *GoogleFlow) googleflowOption {
	return func(m *GoogleFlowMutation) {
		m.oldValue = func(context.Context) (*GoogleFlow, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GoogleFlowMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GoogleFlowMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GoogleFlowMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *GoogleFlowMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().GoogleFlow.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *GoogleFlowMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *GoogleFlowMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the GoogleFlow entity.
// If the GoogleFlow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoogleFlowMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *GoogleFlowMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetState sets the "state" field.
func (m *GoogleFlowMutation) SetState(s string) {
	m.state = &s
}

// State returns the value of the "state" field in the mutation.
func (m *GoogleFlowMutation) State() (r string, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the GoogleFlow entity.
// If the GoogleFlow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoogleFlowMutation) OldState(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// ResetState resets all changes to the "state" field.
func (m *GoogleFlowMutation) ResetState() {
	m.state = nil
}

// SetVerifier sets the "verifier" field.
func (m *GoogleFlowMutation) SetVerifier(s string) {
	m.verifier = &s
}

// Verifier returns the value of the "verifier" field in the mutation.
func (m *GoogleFlowMutation) Verifier() (r string, exists bool) {
	v := m.verifier
	if v == nil {
		return
	}
	return *v, true
}

// OldVerifier returns the old "verifier" field's value of the GoogleFlow entity.
// If the GoogleFlow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoogleFlowMutation) OldVerifier(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVerifier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVerifier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVerifier: %w", err)
	}
	return oldValue.Verifier, nil
}

// ResetVerifier resets all changes to the "verifier" field.
func (m *GoogleFlowMutation) ResetVerifier() {
	m.verifier = nil
}

// SetChallenge sets the "challenge" field.
func (m *GoogleFlowMutation) SetChallenge(s string) {
	m.challenge = &s
}

// Challenge returns the value of the "challenge" field in the mutation.
func (m *GoogleFlowMutation) Challenge() (r string, exists bool) {
	v := m.challenge
	if v == nil {
		return
	}
	return *v, true
}

// OldChallenge returns the old "challenge" field's value of the GoogleFlow entity.
// If the GoogleFlow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoogleFlowMutation) OldChallenge(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChallenge is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChallenge requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChallenge: %w", err)
	}
	return oldValue.Challenge, nil
}

// ResetChallenge resets all changes to the "challenge" field.
func (m *GoogleFlowMutation) ResetChallenge() {
	m.challenge = nil
}

// SetNextURL sets the "next_url" field.
func (m *GoogleFlowMutation) SetNextURL(s string) {
	m.next_url = &s
}

// NextURL returns the value of the "next_url" field in the mutation.
func (m *GoogleFlowMutation) NextURL() (r string, exists bool) {
	v := m.next_url
	if v == nil {
		return
	}
	return *v, true
}

// OldNextURL returns the old "next_url" field's value of the GoogleFlow entity.
// If the GoogleFlow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoogleFlowMutation) OldNextURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNextURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNextURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNextURL: %w", err)
	}
	return oldValue.NextURL, nil
}

// ResetNextURL resets all changes to the "next_url" field.
func (m *GoogleFlowMutation) ResetNextURL() {
	m.next_url = nil
}

// SetOrganization sets the "organization" field.
func (m *GoogleFlowMutation) SetOrganization(s string) {
	m.organization = &s
}

// Organization returns the value of the "organization" field in the mutation.
func (m *GoogleFlowMutation) Organization() (r string, exists bool) {
	v := m.organization
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganization returns the old "organization" field's value of the GoogleFlow entity.
// If the GoogleFlow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoogleFlowMutation) OldOrganization(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganization is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganization requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganization: %w", err)
	}
	return oldValue.Organization, nil
}

// ClearOrganization clears the value of the "organization" field.
func (m *GoogleFlowMutation) ClearOrganization() {
	m.organization = nil
	m.clearedFields[googleflow.FieldOrganization] = struct{}{}
}

// OrganizationCleared returns if the "organization" field was cleared in this mutation.
func (m *GoogleFlowMutation) OrganizationCleared() bool {
	_, ok := m.clearedFields[googleflow.FieldOrganization]
	return ok
}

// ResetOrganization resets all changes to the "organization" field.
func (m *GoogleFlowMutation) ResetOrganization() {
	m.organization = nil
	delete(m.clearedFields, googleflow.FieldOrganization)
}

// SetDeviceIdentifier sets the "device_identifier" field.
func (m *GoogleFlowMutation) SetDeviceIdentifier(s string) {
	m.device_identifier = &s
}

// DeviceIdentifier returns the value of the "device_identifier" field in the mutation.
func (m *GoogleFlowMutation) DeviceIdentifier() (r string, exists bool) {
	v := m.device_identifier
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceIdentifier returns the old "device_identifier" field's value of the GoogleFlow entity.
// If the GoogleFlow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoogleFlowMutation) OldDeviceIdentifier(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceIdentifier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceIdentifier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceIdentifier: %w", err)
	}
	return oldValue.DeviceIdentifier, nil
}

// ClearDeviceIdentifier clears the value of the "device_identifier" field.
func (m *GoogleFlowMutation) ClearDeviceIdentifier() {
	m.device_identifier = nil
	m.clearedFields[googleflow.FieldDeviceIdentifier] = struct{}{}
}

// DeviceIdentifierCleared returns if the "device_identifier" field was cleared in this mutation.
func (m *GoogleFlowMutation) DeviceIdentifierCleared() bool {
	_, ok := m.clearedFields[googleflow.FieldDeviceIdentifier]
	return ok
}

// ResetDeviceIdentifier resets all changes to the "device_identifier" field.
func (m *GoogleFlowMutation) ResetDeviceIdentifier() {
	m.device_identifier = nil
	delete(m.clearedFields, googleflow.FieldDeviceIdentifier)
}

// Where appends a list predicates to the GoogleFlowMutation builder.
func (m *GoogleFlowMutation) Where(ps ...predicate.GoogleFlow) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the GoogleFlowMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *GoogleFlowMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.GoogleFlow, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *GoogleFlowMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *GoogleFlowMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (GoogleFlow).
func (m *GoogleFlowMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GoogleFlowMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, googleflow.FieldCreatedAt)
	}
	if m.state != nil {
		fields = append(fields, googleflow.FieldState)
	}
	if m.verifier != nil {
		fields = append(fields, googleflow.FieldVerifier)
	}
	if m.challenge != nil {
		fields = append(fields, googleflow.FieldChallenge)
	}
	if m.next_url != nil {
		fields = append(fields, googleflow.FieldNextURL)
	}
	if m.organization != nil {
		fields = append(fields, googleflow.FieldOrganization)
	}
	if m.device_identifier != nil {
		fields = append(fields, googleflow.FieldDeviceIdentifier)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GoogleFlowMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case googleflow.FieldCreatedAt:
		return m.CreatedAt()
	case googleflow.FieldState:
		return m.State()
	case googleflow.FieldVerifier:
		return m.Verifier()
	case googleflow.FieldChallenge:
		return m.Challenge()
	case googleflow.FieldNextURL:
		return m.NextURL()
	case googleflow.FieldOrganization:
		return m.Organization()
	case googleflow.FieldDeviceIdentifier:
		return m.DeviceIdentifier()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GoogleFlowMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case googleflow.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case googleflow.FieldState:
		return m.OldState(ctx)
	case googleflow.FieldVerifier:
		return m.OldVerifier(ctx)
	case googleflow.FieldChallenge:
		return m.OldChallenge(ctx)
	case googleflow.FieldNextURL:
		return m.OldNextURL(ctx)
	case googleflow.FieldOrganization:
		return m.OldOrganization(ctx)
	case googleflow.FieldDeviceIdentifier:
		return m.OldDeviceIdentifier(ctx)
	}
	return nil, fmt.Errorf("unknown GoogleFlow field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GoogleFlowMutation) SetField(name string, value ent.Value) error {
	switch name {
	case googleflow.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case googleflow.FieldState:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	case googleflow.FieldVerifier:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVerifier(v)
		return nil
	case googleflow.FieldChallenge:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChallenge(v)
		return nil
	case googleflow.FieldNextURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNextURL(v)
		return nil
	case googleflow.FieldOrganization:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganization(v)
		return nil
	case googleflow.FieldDeviceIdentifier:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceIdentifier(v)
		return nil
	}
	return fmt.Errorf("unknown GoogleFlow field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GoogleFlowMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GoogleFlowMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GoogleFlowMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown GoogleFlow numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GoogleFlowMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(googleflow.FieldOrganization) {
		fields = append(fields, googleflow.FieldOrganization)
	}
	if m.FieldCleared(googleflow.FieldDeviceIdentifier) {
		fields = append(fields, googleflow.FieldDeviceIdentifier)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GoogleFlowMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GoogleFlowMutation) ClearField(name string) error {
	switch name {
	case googleflow.FieldOrganization:
		m.ClearOrganization()
		return nil
	case googleflow.FieldDeviceIdentifier:
		m.ClearDeviceIdentifier()
		return nil
	}
	return fmt.Errorf("unknown GoogleFlow nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GoogleFlowMutation) ResetField(name string) error {
	switch name {
	case googleflow.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case googleflow.FieldState:
		m.ResetState()
		return nil
	case googleflow.FieldVerifier:
		m.ResetVerifier()
		return nil
	case googleflow.FieldChallenge:
		m.ResetChallenge()
		return nil
	case googleflow.FieldNextURL:
		m.ResetNextURL()
		return nil
	case googleflow.FieldOrganization:
		m.ResetOrganization()
		return nil
	case googleflow.FieldDeviceIdentifier:
		m.ResetDeviceIdentifier()
		return nil
	}
	return fmt.Errorf("unknown GoogleFlow field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GoogleFlowMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GoogleFlowMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GoogleFlowMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GoogleFlowMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GoogleFlowMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GoogleFlowMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GoogleFlowMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown GoogleFlow unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GoogleFlowMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown GoogleFlow edge %s", name)
}

// MagicFlowMutation represents an operation that mutates the MagicFlow nodes in the graph.
type MagicFlowMutation struct {
	config
	op                Op
	typ               string
	id                *int
	created_at        *time.Time
	email             *string
	ip_address        *string
	secret            *string
	next_url          *string
	organization      *string
	device_identifier *string
	clearedFields     map[string]struct{}
	done              bool
	oldValue          func(context.Context) (*MagicFlow, error)
	predicates        []predicate.MagicFlow
}

var _ ent.Mutation = (*MagicFlowMutation)(nil)

// magicflowOption allows management of the mutation configuration using functional options.
type magicflowOption func(*MagicFlowMutation)

// newMagicFlowMutation creates new mutation for the MagicFlow entity.
func newMagicFlowMutation(c config, op Op, opts ...magicflowOption) *MagicFlowMutation {
	m := &MagicFlowMutation{
		config:        c,
		op:            op,
		typ:           TypeMagicFlow,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMagicFlowID sets the ID field of the mutation.
func withMagicFlowID(id int) magicflowOption {
	return func(m *MagicFlowMutation) {
		var (
			err   error
			once  sync.Once
			value *MagicFlow
		)
		m.oldValue = func(ctx context.Context) (*MagicFlow, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MagicFlow.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMagicFlow sets the old MagicFlow of the mutation.
func withMagicFlow(node *MagicFlow) magicflowOption {
	return func(m *MagicFlowMutation) {
		m.oldValue = func(context.Context) (*MagicFlow, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MagicFlowMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MagicFlowMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MagicFlowMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MagicFlowMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().MagicFlow.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *MagicFlowMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MagicFlowMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the MagicFlow entity.
// If the MagicFlow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MagicFlowMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MagicFlowMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetEmail sets the "email" field.
func (m *MagicFlowMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *MagicFlowMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the MagicFlow entity.
// If the MagicFlow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MagicFlowMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *MagicFlowMutation) ResetEmail() {
	m.email = nil
}

// SetIPAddress sets the "ip_address" field.
func (m *MagicFlowMutation) SetIPAddress(s string) {
	m.ip_address = &s
}

// IPAddress returns the value of the "ip_address" field in the mutation.
func (m *MagicFlowMutation) IPAddress() (r string, exists bool) {
	v := m.ip_address
	if v == nil {
		return
	}
	return *v, true
}

// OldIPAddress returns the old "ip_address" field's value of the MagicFlow entity.
// If the MagicFlow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MagicFlowMutation) OldIPAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIPAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIPAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIPAddress: %w", err)
	}
	return oldValue.IPAddress, nil
}

// ResetIPAddress resets all changes to the "ip_address" field.
func (m *MagicFlowMutation) ResetIPAddress() {
	m.ip_address = nil
}

// SetSecret sets the "secret" field.
func (m *MagicFlowMutation) SetSecret(s string) {
	m.secret = &s
}

// Secret returns the value of the "secret" field in the mutation.
func (m *MagicFlowMutation) Secret() (r string, exists bool) {
	v := m.secret
	if v == nil {
		return
	}
	return *v, true
}

// OldSecret returns the old "secret" field's value of the MagicFlow entity.
// If the MagicFlow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MagicFlowMutation) OldSecret(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSecret is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSecret requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSecret: %w", err)
	}
	return oldValue.Secret, nil
}

// ResetSecret resets all changes to the "secret" field.
func (m *MagicFlowMutation) ResetSecret() {
	m.secret = nil
}

// SetNextURL sets the "next_url" field.
func (m *MagicFlowMutation) SetNextURL(s string) {
	m.next_url = &s
}

// NextURL returns the value of the "next_url" field in the mutation.
func (m *MagicFlowMutation) NextURL() (r string, exists bool) {
	v := m.next_url
	if v == nil {
		return
	}
	return *v, true
}

// OldNextURL returns the old "next_url" field's value of the MagicFlow entity.
// If the MagicFlow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MagicFlowMutation) OldNextURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNextURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNextURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNextURL: %w", err)
	}
	return oldValue.NextURL, nil
}

// ResetNextURL resets all changes to the "next_url" field.
func (m *MagicFlowMutation) ResetNextURL() {
	m.next_url = nil
}

// SetOrganization sets the "organization" field.
func (m *MagicFlowMutation) SetOrganization(s string) {
	m.organization = &s
}

// Organization returns the value of the "organization" field in the mutation.
func (m *MagicFlowMutation) Organization() (r string, exists bool) {
	v := m.organization
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganization returns the old "organization" field's value of the MagicFlow entity.
// If the MagicFlow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MagicFlowMutation) OldOrganization(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganization is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganization requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganization: %w", err)
	}
	return oldValue.Organization, nil
}

// ClearOrganization clears the value of the "organization" field.
func (m *MagicFlowMutation) ClearOrganization() {
	m.organization = nil
	m.clearedFields[magicflow.FieldOrganization] = struct{}{}
}

// OrganizationCleared returns if the "organization" field was cleared in this mutation.
func (m *MagicFlowMutation) OrganizationCleared() bool {
	_, ok := m.clearedFields[magicflow.FieldOrganization]
	return ok
}

// ResetOrganization resets all changes to the "organization" field.
func (m *MagicFlowMutation) ResetOrganization() {
	m.organization = nil
	delete(m.clearedFields, magicflow.FieldOrganization)
}

// SetDeviceIdentifier sets the "device_identifier" field.
func (m *MagicFlowMutation) SetDeviceIdentifier(s string) {
	m.device_identifier = &s
}

// DeviceIdentifier returns the value of the "device_identifier" field in the mutation.
func (m *MagicFlowMutation) DeviceIdentifier() (r string, exists bool) {
	v := m.device_identifier
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceIdentifier returns the old "device_identifier" field's value of the MagicFlow entity.
// If the MagicFlow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MagicFlowMutation) OldDeviceIdentifier(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceIdentifier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceIdentifier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceIdentifier: %w", err)
	}
	return oldValue.DeviceIdentifier, nil
}

// ClearDeviceIdentifier clears the value of the "device_identifier" field.
func (m *MagicFlowMutation) ClearDeviceIdentifier() {
	m.device_identifier = nil
	m.clearedFields[magicflow.FieldDeviceIdentifier] = struct{}{}
}

// DeviceIdentifierCleared returns if the "device_identifier" field was cleared in this mutation.
func (m *MagicFlowMutation) DeviceIdentifierCleared() bool {
	_, ok := m.clearedFields[magicflow.FieldDeviceIdentifier]
	return ok
}

// ResetDeviceIdentifier resets all changes to the "device_identifier" field.
func (m *MagicFlowMutation) ResetDeviceIdentifier() {
	m.device_identifier = nil
	delete(m.clearedFields, magicflow.FieldDeviceIdentifier)
}

// Where appends a list predicates to the MagicFlowMutation builder.
func (m *MagicFlowMutation) Where(ps ...predicate.MagicFlow) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MagicFlowMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MagicFlowMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.MagicFlow, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MagicFlowMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MagicFlowMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (MagicFlow).
func (m *MagicFlowMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MagicFlowMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, magicflow.FieldCreatedAt)
	}
	if m.email != nil {
		fields = append(fields, magicflow.FieldEmail)
	}
	if m.ip_address != nil {
		fields = append(fields, magicflow.FieldIPAddress)
	}
	if m.secret != nil {
		fields = append(fields, magicflow.FieldSecret)
	}
	if m.next_url != nil {
		fields = append(fields, magicflow.FieldNextURL)
	}
	if m.organization != nil {
		fields = append(fields, magicflow.FieldOrganization)
	}
	if m.device_identifier != nil {
		fields = append(fields, magicflow.FieldDeviceIdentifier)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MagicFlowMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case magicflow.FieldCreatedAt:
		return m.CreatedAt()
	case magicflow.FieldEmail:
		return m.Email()
	case magicflow.FieldIPAddress:
		return m.IPAddress()
	case magicflow.FieldSecret:
		return m.Secret()
	case magicflow.FieldNextURL:
		return m.NextURL()
	case magicflow.FieldOrganization:
		return m.Organization()
	case magicflow.FieldDeviceIdentifier:
		return m.DeviceIdentifier()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MagicFlowMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case magicflow.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case magicflow.FieldEmail:
		return m.OldEmail(ctx)
	case magicflow.FieldIPAddress:
		return m.OldIPAddress(ctx)
	case magicflow.FieldSecret:
		return m.OldSecret(ctx)
	case magicflow.FieldNextURL:
		return m.OldNextURL(ctx)
	case magicflow.FieldOrganization:
		return m.OldOrganization(ctx)
	case magicflow.FieldDeviceIdentifier:
		return m.OldDeviceIdentifier(ctx)
	}
	return nil, fmt.Errorf("unknown MagicFlow field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MagicFlowMutation) SetField(name string, value ent.Value) error {
	switch name {
	case magicflow.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case magicflow.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case magicflow.FieldIPAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIPAddress(v)
		return nil
	case magicflow.FieldSecret:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSecret(v)
		return nil
	case magicflow.FieldNextURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNextURL(v)
		return nil
	case magicflow.FieldOrganization:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganization(v)
		return nil
	case magicflow.FieldDeviceIdentifier:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceIdentifier(v)
		return nil
	}
	return fmt.Errorf("unknown MagicFlow field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MagicFlowMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MagicFlowMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MagicFlowMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown MagicFlow numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MagicFlowMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(magicflow.FieldOrganization) {
		fields = append(fields, magicflow.FieldOrganization)
	}
	if m.FieldCleared(magicflow.FieldDeviceIdentifier) {
		fields = append(fields, magicflow.FieldDeviceIdentifier)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MagicFlowMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MagicFlowMutation) ClearField(name string) error {
	switch name {
	case magicflow.FieldOrganization:
		m.ClearOrganization()
		return nil
	case magicflow.FieldDeviceIdentifier:
		m.ClearDeviceIdentifier()
		return nil
	}
	return fmt.Errorf("unknown MagicFlow nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MagicFlowMutation) ResetField(name string) error {
	switch name {
	case magicflow.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case magicflow.FieldEmail:
		m.ResetEmail()
		return nil
	case magicflow.FieldIPAddress:
		m.ResetIPAddress()
		return nil
	case magicflow.FieldSecret:
		m.ResetSecret()
		return nil
	case magicflow.FieldNextURL:
		m.ResetNextURL()
		return nil
	case magicflow.FieldOrganization:
		m.ResetOrganization()
		return nil
	case magicflow.FieldDeviceIdentifier:
		m.ResetDeviceIdentifier()
		return nil
	}
	return fmt.Errorf("unknown MagicFlow field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MagicFlowMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MagicFlowMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MagicFlowMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MagicFlowMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MagicFlowMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MagicFlowMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MagicFlowMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown MagicFlow unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MagicFlowMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown MagicFlow edge %s", name)
}
