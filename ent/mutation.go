/*
	Copyright 2022 Loophole Labs

	Licensed under the Apache License, Version 2.0 (the "License");
	you may not use this file except in compliance with the License.
	You may obtain a copy of the License at

		   http://www.apache.org/licenses/LICENSE-2.0

	Unless required by applicable law or agreed to in writing, software
	distributed under the License is distributed on an "AS IS" BASIS,
	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	See the License for the specific language governing permissions and
	limitations under the License.
*/

// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"github.com/loopholelabs/auth/ent/githubflow"
	"github.com/loopholelabs/auth/ent/predicate"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeGithubFlow = "GithubFlow"
)

// GithubFlowMutation represents an operation that mutates the GithubFlow nodes in the graph.
type GithubFlowMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *time.Time
	state         *string
	verifier      *string
	challenge     *string
	next_url      *string
	organization  *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*GithubFlow, error)
	predicates    []predicate.GithubFlow
}

var _ ent.Mutation = (*GithubFlowMutation)(nil)

// githubflowOption allows management of the mutation configuration using functional options.
type githubflowOption func(*GithubFlowMutation)

// newGithubFlowMutation creates new mutation for the GithubFlow entity.
func newGithubFlowMutation(c config, op Op, opts ...githubflowOption) *GithubFlowMutation {
	m := &GithubFlowMutation{
		config:        c,
		op:            op,
		typ:           TypeGithubFlow,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGithubFlowID sets the ID field of the mutation.
func withGithubFlowID(id int) githubflowOption {
	return func(m *GithubFlowMutation) {
		var (
			err   error
			once  sync.Once
			value *GithubFlow
		)
		m.oldValue = func(ctx context.Context) (*GithubFlow, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().GithubFlow.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGithubFlow sets the old GithubFlow of the mutation.
func withGithubFlow(node *GithubFlow) githubflowOption {
	return func(m *GithubFlowMutation) {
		m.oldValue = func(context.Context) (*GithubFlow, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GithubFlowMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GithubFlowMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GithubFlowMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *GithubFlowMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().GithubFlow.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *GithubFlowMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *GithubFlowMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the GithubFlow entity.
// If the GithubFlow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GithubFlowMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *GithubFlowMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetState sets the "state" field.
func (m *GithubFlowMutation) SetState(s string) {
	m.state = &s
}

// State returns the value of the "state" field in the mutation.
func (m *GithubFlowMutation) State() (r string, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the GithubFlow entity.
// If the GithubFlow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GithubFlowMutation) OldState(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// ResetState resets all changes to the "state" field.
func (m *GithubFlowMutation) ResetState() {
	m.state = nil
}

// SetVerifier sets the "verifier" field.
func (m *GithubFlowMutation) SetVerifier(s string) {
	m.verifier = &s
}

// Verifier returns the value of the "verifier" field in the mutation.
func (m *GithubFlowMutation) Verifier() (r string, exists bool) {
	v := m.verifier
	if v == nil {
		return
	}
	return *v, true
}

// OldVerifier returns the old "verifier" field's value of the GithubFlow entity.
// If the GithubFlow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GithubFlowMutation) OldVerifier(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVerifier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVerifier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVerifier: %w", err)
	}
	return oldValue.Verifier, nil
}

// ResetVerifier resets all changes to the "verifier" field.
func (m *GithubFlowMutation) ResetVerifier() {
	m.verifier = nil
}

// SetChallenge sets the "challenge" field.
func (m *GithubFlowMutation) SetChallenge(s string) {
	m.challenge = &s
}

// Challenge returns the value of the "challenge" field in the mutation.
func (m *GithubFlowMutation) Challenge() (r string, exists bool) {
	v := m.challenge
	if v == nil {
		return
	}
	return *v, true
}

// OldChallenge returns the old "challenge" field's value of the GithubFlow entity.
// If the GithubFlow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GithubFlowMutation) OldChallenge(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChallenge is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChallenge requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChallenge: %w", err)
	}
	return oldValue.Challenge, nil
}

// ResetChallenge resets all changes to the "challenge" field.
func (m *GithubFlowMutation) ResetChallenge() {
	m.challenge = nil
}

// SetNextURL sets the "next_url" field.
func (m *GithubFlowMutation) SetNextURL(s string) {
	m.next_url = &s
}

// NextURL returns the value of the "next_url" field in the mutation.
func (m *GithubFlowMutation) NextURL() (r string, exists bool) {
	v := m.next_url
	if v == nil {
		return
	}
	return *v, true
}

// OldNextURL returns the old "next_url" field's value of the GithubFlow entity.
// If the GithubFlow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GithubFlowMutation) OldNextURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNextURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNextURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNextURL: %w", err)
	}
	return oldValue.NextURL, nil
}

// ResetNextURL resets all changes to the "next_url" field.
func (m *GithubFlowMutation) ResetNextURL() {
	m.next_url = nil
}

// SetOrganization sets the "organization" field.
func (m *GithubFlowMutation) SetOrganization(s string) {
	m.organization = &s
}

// Organization returns the value of the "organization" field in the mutation.
func (m *GithubFlowMutation) Organization() (r string, exists bool) {
	v := m.organization
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganization returns the old "organization" field's value of the GithubFlow entity.
// If the GithubFlow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GithubFlowMutation) OldOrganization(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganization is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganization requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganization: %w", err)
	}
	return oldValue.Organization, nil
}

// ClearOrganization clears the value of the "organization" field.
func (m *GithubFlowMutation) ClearOrganization() {
	m.organization = nil
	m.clearedFields[githubflow.FieldOrganization] = struct{}{}
}

// OrganizationCleared returns if the "organization" field was cleared in this mutation.
func (m *GithubFlowMutation) OrganizationCleared() bool {
	_, ok := m.clearedFields[githubflow.FieldOrganization]
	return ok
}

// ResetOrganization resets all changes to the "organization" field.
func (m *GithubFlowMutation) ResetOrganization() {
	m.organization = nil
	delete(m.clearedFields, githubflow.FieldOrganization)
}

// Where appends a list predicates to the GithubFlowMutation builder.
func (m *GithubFlowMutation) Where(ps ...predicate.GithubFlow) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *GithubFlowMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (GithubFlow).
func (m *GithubFlowMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GithubFlowMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, githubflow.FieldCreatedAt)
	}
	if m.state != nil {
		fields = append(fields, githubflow.FieldState)
	}
	if m.verifier != nil {
		fields = append(fields, githubflow.FieldVerifier)
	}
	if m.challenge != nil {
		fields = append(fields, githubflow.FieldChallenge)
	}
	if m.next_url != nil {
		fields = append(fields, githubflow.FieldNextURL)
	}
	if m.organization != nil {
		fields = append(fields, githubflow.FieldOrganization)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GithubFlowMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case githubflow.FieldCreatedAt:
		return m.CreatedAt()
	case githubflow.FieldState:
		return m.State()
	case githubflow.FieldVerifier:
		return m.Verifier()
	case githubflow.FieldChallenge:
		return m.Challenge()
	case githubflow.FieldNextURL:
		return m.NextURL()
	case githubflow.FieldOrganization:
		return m.Organization()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GithubFlowMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case githubflow.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case githubflow.FieldState:
		return m.OldState(ctx)
	case githubflow.FieldVerifier:
		return m.OldVerifier(ctx)
	case githubflow.FieldChallenge:
		return m.OldChallenge(ctx)
	case githubflow.FieldNextURL:
		return m.OldNextURL(ctx)
	case githubflow.FieldOrganization:
		return m.OldOrganization(ctx)
	}
	return nil, fmt.Errorf("unknown GithubFlow field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GithubFlowMutation) SetField(name string, value ent.Value) error {
	switch name {
	case githubflow.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case githubflow.FieldState:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	case githubflow.FieldVerifier:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVerifier(v)
		return nil
	case githubflow.FieldChallenge:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChallenge(v)
		return nil
	case githubflow.FieldNextURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNextURL(v)
		return nil
	case githubflow.FieldOrganization:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganization(v)
		return nil
	}
	return fmt.Errorf("unknown GithubFlow field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GithubFlowMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GithubFlowMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GithubFlowMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown GithubFlow numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GithubFlowMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(githubflow.FieldOrganization) {
		fields = append(fields, githubflow.FieldOrganization)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GithubFlowMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GithubFlowMutation) ClearField(name string) error {
	switch name {
	case githubflow.FieldOrganization:
		m.ClearOrganization()
		return nil
	}
	return fmt.Errorf("unknown GithubFlow nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GithubFlowMutation) ResetField(name string) error {
	switch name {
	case githubflow.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case githubflow.FieldState:
		m.ResetState()
		return nil
	case githubflow.FieldVerifier:
		m.ResetVerifier()
		return nil
	case githubflow.FieldChallenge:
		m.ResetChallenge()
		return nil
	case githubflow.FieldNextURL:
		m.ResetNextURL()
		return nil
	case githubflow.FieldOrganization:
		m.ResetOrganization()
		return nil
	}
	return fmt.Errorf("unknown GithubFlow field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GithubFlowMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GithubFlowMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GithubFlowMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GithubFlowMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GithubFlowMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GithubFlowMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GithubFlowMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown GithubFlow unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GithubFlowMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown GithubFlow edge %s", name)
}
