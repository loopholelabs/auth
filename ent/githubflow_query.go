/*
	Copyright 2022 Loophole Labs

	Licensed under the Apache License, Version 2.0 (the "License");
	you may not use this file except in compliance with the License.
	You may obtain a copy of the License at

		   http://www.apache.org/licenses/LICENSE-2.0

	Unless required by applicable law or agreed to in writing, software
	distributed under the License is distributed on an "AS IS" BASIS,
	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	See the License for the specific language governing permissions and
	limitations under the License.
*/

// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"math"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"entgo.io/ent/schema/field"
	"github.com/loopholelabs/auth/ent/githubflow"
	"github.com/loopholelabs/auth/ent/predicate"
)

// GithubFlowQuery is the builder for querying GithubFlow entities.
type GithubFlowQuery struct {
	config
	limit      *int
	offset     *int
	unique     *bool
	order      []OrderFunc
	fields     []string
	predicates []predicate.GithubFlow
	// intermediate query (i.e. traversal path).
	sql  *sql.Selector
	path func(context.Context) (*sql.Selector, error)
}

// Where adds a new predicate for the GithubFlowQuery builder.
func (gfq *GithubFlowQuery) Where(ps ...predicate.GithubFlow) *GithubFlowQuery {
	gfq.predicates = append(gfq.predicates, ps...)
	return gfq
}

// Limit adds a limit step to the query.
func (gfq *GithubFlowQuery) Limit(limit int) *GithubFlowQuery {
	gfq.limit = &limit
	return gfq
}

// Offset adds an offset step to the query.
func (gfq *GithubFlowQuery) Offset(offset int) *GithubFlowQuery {
	gfq.offset = &offset
	return gfq
}

// Unique configures the query builder to filter duplicate records on query.
// By default, unique is set to true, and can be disabled using this method.
func (gfq *GithubFlowQuery) Unique(unique bool) *GithubFlowQuery {
	gfq.unique = &unique
	return gfq
}

// Order adds an order step to the query.
func (gfq *GithubFlowQuery) Order(o ...OrderFunc) *GithubFlowQuery {
	gfq.order = append(gfq.order, o...)
	return gfq
}

// First returns the first GithubFlow entity from the query.
// Returns a *NotFoundError when no GithubFlow was found.
func (gfq *GithubFlowQuery) First(ctx context.Context) (*GithubFlow, error) {
	nodes, err := gfq.Limit(1).All(ctx)
	if err != nil {
		return nil, err
	}
	if len(nodes) == 0 {
		return nil, &NotFoundError{githubflow.Label}
	}
	return nodes[0], nil
}

// FirstX is like First, but panics if an error occurs.
func (gfq *GithubFlowQuery) FirstX(ctx context.Context) *GithubFlow {
	node, err := gfq.First(ctx)
	if err != nil && !IsNotFound(err) {
		panic(err)
	}
	return node
}

// FirstID returns the first GithubFlow ID from the query.
// Returns a *NotFoundError when no GithubFlow ID was found.
func (gfq *GithubFlowQuery) FirstID(ctx context.Context) (id int, err error) {
	var ids []int
	if ids, err = gfq.Limit(1).IDs(ctx); err != nil {
		return
	}
	if len(ids) == 0 {
		err = &NotFoundError{githubflow.Label}
		return
	}
	return ids[0], nil
}

// FirstIDX is like FirstID, but panics if an error occurs.
func (gfq *GithubFlowQuery) FirstIDX(ctx context.Context) int {
	id, err := gfq.FirstID(ctx)
	if err != nil && !IsNotFound(err) {
		panic(err)
	}
	return id
}

// Only returns a single GithubFlow entity found by the query, ensuring it only returns one.
// Returns a *NotSingularError when more than one GithubFlow entity is found.
// Returns a *NotFoundError when no GithubFlow entities are found.
func (gfq *GithubFlowQuery) Only(ctx context.Context) (*GithubFlow, error) {
	nodes, err := gfq.Limit(2).All(ctx)
	if err != nil {
		return nil, err
	}
	switch len(nodes) {
	case 1:
		return nodes[0], nil
	case 0:
		return nil, &NotFoundError{githubflow.Label}
	default:
		return nil, &NotSingularError{githubflow.Label}
	}
}

// OnlyX is like Only, but panics if an error occurs.
func (gfq *GithubFlowQuery) OnlyX(ctx context.Context) *GithubFlow {
	node, err := gfq.Only(ctx)
	if err != nil {
		panic(err)
	}
	return node
}

// OnlyID is like Only, but returns the only GithubFlow ID in the query.
// Returns a *NotSingularError when more than one GithubFlow ID is found.
// Returns a *NotFoundError when no entities are found.
func (gfq *GithubFlowQuery) OnlyID(ctx context.Context) (id int, err error) {
	var ids []int
	if ids, err = gfq.Limit(2).IDs(ctx); err != nil {
		return
	}
	switch len(ids) {
	case 1:
		id = ids[0]
	case 0:
		err = &NotFoundError{githubflow.Label}
	default:
		err = &NotSingularError{githubflow.Label}
	}
	return
}

// OnlyIDX is like OnlyID, but panics if an error occurs.
func (gfq *GithubFlowQuery) OnlyIDX(ctx context.Context) int {
	id, err := gfq.OnlyID(ctx)
	if err != nil {
		panic(err)
	}
	return id
}

// All executes the query and returns a list of GithubFlows.
func (gfq *GithubFlowQuery) All(ctx context.Context) ([]*GithubFlow, error) {
	if err := gfq.prepareQuery(ctx); err != nil {
		return nil, err
	}
	return gfq.sqlAll(ctx)
}

// AllX is like All, but panics if an error occurs.
func (gfq *GithubFlowQuery) AllX(ctx context.Context) []*GithubFlow {
	nodes, err := gfq.All(ctx)
	if err != nil {
		panic(err)
	}
	return nodes
}

// IDs executes the query and returns a list of GithubFlow IDs.
func (gfq *GithubFlowQuery) IDs(ctx context.Context) ([]int, error) {
	var ids []int
	if err := gfq.Select(githubflow.FieldID).Scan(ctx, &ids); err != nil {
		return nil, err
	}
	return ids, nil
}

// IDsX is like IDs, but panics if an error occurs.
func (gfq *GithubFlowQuery) IDsX(ctx context.Context) []int {
	ids, err := gfq.IDs(ctx)
	if err != nil {
		panic(err)
	}
	return ids
}

// Count returns the count of the given query.
func (gfq *GithubFlowQuery) Count(ctx context.Context) (int, error) {
	if err := gfq.prepareQuery(ctx); err != nil {
		return 0, err
	}
	return gfq.sqlCount(ctx)
}

// CountX is like Count, but panics if an error occurs.
func (gfq *GithubFlowQuery) CountX(ctx context.Context) int {
	count, err := gfq.Count(ctx)
	if err != nil {
		panic(err)
	}
	return count
}

// Exist returns true if the query has elements in the graph.
func (gfq *GithubFlowQuery) Exist(ctx context.Context) (bool, error) {
	if err := gfq.prepareQuery(ctx); err != nil {
		return false, err
	}
	return gfq.sqlExist(ctx)
}

// ExistX is like Exist, but panics if an error occurs.
func (gfq *GithubFlowQuery) ExistX(ctx context.Context) bool {
	exist, err := gfq.Exist(ctx)
	if err != nil {
		panic(err)
	}
	return exist
}

// Clone returns a duplicate of the GithubFlowQuery builder, including all associated steps. It can be
// used to prepare common query builders and use them differently after the clone is made.
func (gfq *GithubFlowQuery) Clone() *GithubFlowQuery {
	if gfq == nil {
		return nil
	}
	return &GithubFlowQuery{
		config:     gfq.config,
		limit:      gfq.limit,
		offset:     gfq.offset,
		order:      append([]OrderFunc{}, gfq.order...),
		predicates: append([]predicate.GithubFlow{}, gfq.predicates...),
		// clone intermediate query.
		sql:    gfq.sql.Clone(),
		path:   gfq.path,
		unique: gfq.unique,
	}
}

// GroupBy is used to group vertices by one or more fields/columns.
// It is often used with aggregate functions, like: count, max, mean, min, sum.
//
// Example:
//
//	var v []struct {
//		CreatedAt time.Time `json:"created_at,omitempty"`
//		Count int `json:"count,omitempty"`
//	}
//
//	client.GithubFlow.Query().
//		GroupBy(githubflow.FieldCreatedAt).
//		Aggregate(ent.Count()).
//		Scan(ctx, &v)
func (gfq *GithubFlowQuery) GroupBy(field string, fields ...string) *GithubFlowGroupBy {
	grbuild := &GithubFlowGroupBy{config: gfq.config}
	grbuild.fields = append([]string{field}, fields...)
	grbuild.path = func(ctx context.Context) (prev *sql.Selector, err error) {
		if err := gfq.prepareQuery(ctx); err != nil {
			return nil, err
		}
		return gfq.sqlQuery(ctx), nil
	}
	grbuild.label = githubflow.Label
	grbuild.flds, grbuild.scan = &grbuild.fields, grbuild.Scan
	return grbuild
}

// Select allows the selection one or more fields/columns for the given query,
// instead of selecting all fields in the entity.
//
// Example:
//
//	var v []struct {
//		CreatedAt time.Time `json:"created_at,omitempty"`
//	}
//
//	client.GithubFlow.Query().
//		Select(githubflow.FieldCreatedAt).
//		Scan(ctx, &v)
func (gfq *GithubFlowQuery) Select(fields ...string) *GithubFlowSelect {
	gfq.fields = append(gfq.fields, fields...)
	selbuild := &GithubFlowSelect{GithubFlowQuery: gfq}
	selbuild.label = githubflow.Label
	selbuild.flds, selbuild.scan = &gfq.fields, selbuild.Scan
	return selbuild
}

// Aggregate returns a GithubFlowSelect configured with the given aggregations.
func (gfq *GithubFlowQuery) Aggregate(fns ...AggregateFunc) *GithubFlowSelect {
	return gfq.Select().Aggregate(fns...)
}

func (gfq *GithubFlowQuery) prepareQuery(ctx context.Context) error {
	for _, f := range gfq.fields {
		if !githubflow.ValidColumn(f) {
			return &ValidationError{Name: f, err: fmt.Errorf("ent: invalid field %q for query", f)}
		}
	}
	if gfq.path != nil {
		prev, err := gfq.path(ctx)
		if err != nil {
			return err
		}
		gfq.sql = prev
	}
	return nil
}

func (gfq *GithubFlowQuery) sqlAll(ctx context.Context, hooks ...queryHook) ([]*GithubFlow, error) {
	var (
		nodes = []*GithubFlow{}
		_spec = gfq.querySpec()
	)
	_spec.ScanValues = func(columns []string) ([]any, error) {
		return (*GithubFlow).scanValues(nil, columns)
	}
	_spec.Assign = func(columns []string, values []any) error {
		node := &GithubFlow{config: gfq.config}
		nodes = append(nodes, node)
		return node.assignValues(columns, values)
	}
	for i := range hooks {
		hooks[i](ctx, _spec)
	}
	if err := sqlgraph.QueryNodes(ctx, gfq.driver, _spec); err != nil {
		return nil, err
	}
	if len(nodes) == 0 {
		return nodes, nil
	}
	return nodes, nil
}

func (gfq *GithubFlowQuery) sqlCount(ctx context.Context) (int, error) {
	_spec := gfq.querySpec()
	_spec.Node.Columns = gfq.fields
	if len(gfq.fields) > 0 {
		_spec.Unique = gfq.unique != nil && *gfq.unique
	}
	return sqlgraph.CountNodes(ctx, gfq.driver, _spec)
}

func (gfq *GithubFlowQuery) sqlExist(ctx context.Context) (bool, error) {
	switch _, err := gfq.FirstID(ctx); {
	case IsNotFound(err):
		return false, nil
	case err != nil:
		return false, fmt.Errorf("ent: check existence: %w", err)
	default:
		return true, nil
	}
}

func (gfq *GithubFlowQuery) querySpec() *sqlgraph.QuerySpec {
	_spec := &sqlgraph.QuerySpec{
		Node: &sqlgraph.NodeSpec{
			Table:   githubflow.Table,
			Columns: githubflow.Columns,
			ID: &sqlgraph.FieldSpec{
				Type:   field.TypeInt,
				Column: githubflow.FieldID,
			},
		},
		From:   gfq.sql,
		Unique: true,
	}
	if unique := gfq.unique; unique != nil {
		_spec.Unique = *unique
	}
	if fields := gfq.fields; len(fields) > 0 {
		_spec.Node.Columns = make([]string, 0, len(fields))
		_spec.Node.Columns = append(_spec.Node.Columns, githubflow.FieldID)
		for i := range fields {
			if fields[i] != githubflow.FieldID {
				_spec.Node.Columns = append(_spec.Node.Columns, fields[i])
			}
		}
	}
	if ps := gfq.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if limit := gfq.limit; limit != nil {
		_spec.Limit = *limit
	}
	if offset := gfq.offset; offset != nil {
		_spec.Offset = *offset
	}
	if ps := gfq.order; len(ps) > 0 {
		_spec.Order = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	return _spec
}

func (gfq *GithubFlowQuery) sqlQuery(ctx context.Context) *sql.Selector {
	builder := sql.Dialect(gfq.driver.Dialect())
	t1 := builder.Table(githubflow.Table)
	columns := gfq.fields
	if len(columns) == 0 {
		columns = githubflow.Columns
	}
	selector := builder.Select(t1.Columns(columns...)...).From(t1)
	if gfq.sql != nil {
		selector = gfq.sql
		selector.Select(selector.Columns(columns...)...)
	}
	if gfq.unique != nil && *gfq.unique {
		selector.Distinct()
	}
	for _, p := range gfq.predicates {
		p(selector)
	}
	for _, p := range gfq.order {
		p(selector)
	}
	if offset := gfq.offset; offset != nil {
		// limit is mandatory for offset clause. We start
		// with default value, and override it below if needed.
		selector.Offset(*offset).Limit(math.MaxInt32)
	}
	if limit := gfq.limit; limit != nil {
		selector.Limit(*limit)
	}
	return selector
}

// GithubFlowGroupBy is the group-by builder for GithubFlow entities.
type GithubFlowGroupBy struct {
	config
	selector
	fields []string
	fns    []AggregateFunc
	// intermediate query (i.e. traversal path).
	sql  *sql.Selector
	path func(context.Context) (*sql.Selector, error)
}

// Aggregate adds the given aggregation functions to the group-by query.
func (gfgb *GithubFlowGroupBy) Aggregate(fns ...AggregateFunc) *GithubFlowGroupBy {
	gfgb.fns = append(gfgb.fns, fns...)
	return gfgb
}

// Scan applies the group-by query and scans the result into the given value.
func (gfgb *GithubFlowGroupBy) Scan(ctx context.Context, v any) error {
	query, err := gfgb.path(ctx)
	if err != nil {
		return err
	}
	gfgb.sql = query
	return gfgb.sqlScan(ctx, v)
}

func (gfgb *GithubFlowGroupBy) sqlScan(ctx context.Context, v any) error {
	for _, f := range gfgb.fields {
		if !githubflow.ValidColumn(f) {
			return &ValidationError{Name: f, err: fmt.Errorf("invalid field %q for group-by", f)}
		}
	}
	selector := gfgb.sqlQuery()
	if err := selector.Err(); err != nil {
		return err
	}
	rows := &sql.Rows{}
	query, args := selector.Query()
	if err := gfgb.driver.Query(ctx, query, args, rows); err != nil {
		return err
	}
	defer rows.Close()
	return sql.ScanSlice(rows, v)
}

func (gfgb *GithubFlowGroupBy) sqlQuery() *sql.Selector {
	selector := gfgb.sql.Select()
	aggregation := make([]string, 0, len(gfgb.fns))
	for _, fn := range gfgb.fns {
		aggregation = append(aggregation, fn(selector))
	}
	if len(selector.SelectedColumns()) == 0 {
		columns := make([]string, 0, len(gfgb.fields)+len(gfgb.fns))
		for _, f := range gfgb.fields {
			columns = append(columns, selector.C(f))
		}
		columns = append(columns, aggregation...)
		selector.Select(columns...)
	}
	return selector.GroupBy(selector.Columns(gfgb.fields...)...)
}

// GithubFlowSelect is the builder for selecting fields of GithubFlow entities.
type GithubFlowSelect struct {
	*GithubFlowQuery
	selector
	// intermediate query (i.e. traversal path).
	sql *sql.Selector
}

// Aggregate adds the given aggregation functions to the selector query.
func (gfs *GithubFlowSelect) Aggregate(fns ...AggregateFunc) *GithubFlowSelect {
	gfs.fns = append(gfs.fns, fns...)
	return gfs
}

// Scan applies the selector query and scans the result into the given value.
func (gfs *GithubFlowSelect) Scan(ctx context.Context, v any) error {
	if err := gfs.prepareQuery(ctx); err != nil {
		return err
	}
	gfs.sql = gfs.GithubFlowQuery.sqlQuery(ctx)
	return gfs.sqlScan(ctx, v)
}

func (gfs *GithubFlowSelect) sqlScan(ctx context.Context, v any) error {
	aggregation := make([]string, 0, len(gfs.fns))
	for _, fn := range gfs.fns {
		aggregation = append(aggregation, fn(gfs.sql))
	}
	switch n := len(*gfs.selector.flds); {
	case n == 0 && len(aggregation) > 0:
		gfs.sql.Select(aggregation...)
	case n != 0 && len(aggregation) > 0:
		gfs.sql.AppendSelect(aggregation...)
	}
	rows := &sql.Rows{}
	query, args := gfs.sql.Query()
	if err := gfs.driver.Query(ctx, query, args, rows); err != nil {
		return err
	}
	defer rows.Close()
	return sql.ScanSlice(rows, v)
}
